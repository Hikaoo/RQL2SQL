/**
 * This document describe the Relational Query Language.
 * @author Lucas Venezian Povoa and Dérick Welman Brock Rangel
 * @since 24th Setember, 2010
 */

/*
 * Compiler options
 */
options {

	/*
	 * Esse atributo determina que as classes não devem ser estáticas.
	 */
	STATIC = false;

	GRAMMAR_ENCODING = "ISO-8859-1";

	/*
	 * Esse atributo determina que o Analisador Sintático deve mostrar na saída-padrão
	 * quais são os não-terminais que estão sendo "executados" e quais são os tokens que
	 * estão sendo consumidos em cada um deles.
	 */
	DEBUG_LOOKAHEAD = false;
}
 
PARSER_BEGIN( RelationalQueryLanguage )
package br.edu.ifsp.parser;

/*
 * Import session
 */
import br.edu.ifsp.symbolTable.*;
import br.edu.ifsp.syntacticTree.*;
import br.edu.ifsp.syntacticTree.interfaces.*;

public class RelationalQueryLanguage {

	/**
	 * Method used to link a founded token with his name.
	 * 
	 * @see the book DELAMARO, M. E. Como Construir um Compilador: Utilizando
	 *      Ferramentas Java. São Paulo: Novatec. 2004
	 * @param x
	 * @return
	 */
	public static String im(int x) {

		int k;
		String s;

		s = tokenImage[x];
		k = s.lastIndexOf("\u005c"");

		try {

			s.substring(1, k);
		} catch (Exception exception) {
		}

		return s;
	}
	  
}//RelationalQueryLanguage class
PARSER_END( RelationalQueryLanguage )

/*************************************************************************************************************
/*											Compiler Options												 *
/*************************************************************************************************************/

TOKEN_MGR_DECLS: {
  
	int countLexError = 0;

	public int foundLexError() {
	  
		return countLexError;
	}
}

/*************************************************************************************************************
/*											Lexical Set														 *
/*************************************************************************************************************/

SKIP: {
		" "
	|	"\n"
	|	"\r"
	|	"\r\n"
}

/**
 * Special tokens
 * @since Setember 24th, 2010
 */
TOKEN : {
       < QUOTE              :   "'"   >
   |   < DOUBLE_QUOTE       :   "\""  >
   |   < PERCENT            :   "%"   >
   |   < AMPERSAND          :   "&"   >
   |   < LEFT_PARENTHESIS   :   "("   >
   |   < RIGHT_PARENTHESIS  :   ")"   >
   |   < ASTERISK           :   "*"   >
   |   < PLUS_SIGN          :   "+"   >
   |   < COMMA              :   ","   >
   |   < MINUS_SIGN         :   "-"   >
   |   < PERIOD             :   "."   >
   |   < SOLIDUS            :   "/"   >
   |   < COLON              :   ":"   >
   |   < SEMICOLON          :   ";"   >
   |   < LESS_THAN          :   "<"   > 
   |   < EQUALS             :   "="   >
   |   < NOT_EQUALS         :   ( "!=" | "<>" ) >
   |   < GREATER_THAN       :   ">"              >
   |   < GREATER_THAN_OR_EQUALS   :   ">="       >
   |   < LESS_THAN_OR_EQUALS      :   "<="       >
   |   < QUESTION_MARK            :   "?"        >
   |   < UNDERSCORE               :   "_"        >
   |   < VERTICAL_BAR             :   "|"        >
   |   < LEFT_BRACKET             :   "["        >
   |   < RIGHT_BRACKET            :   "]"        >
   |   < LEFT_KEY                 :   "{"        >
   |   < RIGHT_KEY                :   "}"        >
   |   < INSTANCEOF				  :   "instanceof" >
   |   < IF                       :   "->"         >
   |   < POWER                    :   "**"         >
}

/**
 * Relational Operations Tokens
 * @since Setember 24th, 2010
 */
TOKEN: {
        < PROJECT_TOKEN	:   "¢" >
   |	< SELECT_TOKEN	:   "£" >
   |	< RENAME_TOKEN	:   "§" >
   |	< EXTEND_TOKEN	:   < AMPERSAND > >
   |	< CROSS_TOKEN	:	"x" >
   |	< NATURAL_JOIN_TOKEN		: "[]" >
   |	< TRANSITIVE_CLOSE_LEFT		: "<<" >
   |	< TRANSITIVE_CLOSE_RIGHT	: ">>" >
}

/**
 * Aggregation operation tokens
 * @since Setember 24th, 2010
 */
TOKEN: {
     < COUNT	: "#" >
   | < SUM		: "$" >
   | < AVG		: "@" >
   | < MAX		: < PLUS_SIGN  > >
   | < MIN		: < MINUS_SIGN > >
}
 
/**
 * Logic operators tokens
 * @since Setember 25th, 2010
 */
TOKEN: {
       < AND   :   "^"   >
   |   < OR    :   "v"   >
   |   < XOR   :   "_v_" >
   |   < NOT   :   "¬"   >
}

/**
 * Data types
 */
TOKEN: {

   < VARCHAR_TYPE   : "VARCHAR" ( < LEFT_PARENTHESIS > < INTEGER > < RIGHT_PARENTHESIS > )? >
|  < CHAR_TYPE      : "CHAR" ( < LEFT_PARENTHESIS > < INTEGER > < RIGHT_PARENTHESIS > )?    >
|  < INTEGER_TYPE   : ( "INT" | "INTEGER" ) ( < LEFT_PARENTHESIS > < INTEGER > < RIGHT_PARENTHESIS > )? >
|  < DOUBLE_TYPE    : ( "DOUBLE"  | "DECIMAL" | "RATIONAL" ) ( < LEFT_PARENTHESIS > < INTEGER > ( < PERIOD > < INTEGER > )? )? >
|  < FLOAT_TYPE     : ( "FLOAT" | "LONG" ) ( < LEFT_PARENTHESIS > < INTEGER > ( < PERIOD > < INTEGER > )? )? >
|  < BLOB_TYPE      : ( "BLOB" | "LONG BLOB" ) >
|  < GEOMETRIC_TYPE : ( "POINT" | "LINE" | "POLYGON" | "MULTI POINTS" | "MULTIPART LINE" | "MULTIPART LINE" ) >
|  < RELATION_TYPE  : ( "DEE" | "DUM" ) >
|  < BOOLEAN_TYPE   : "BOOLEAN" >
}

/**
 * constants
 * @since Setember 25th, 2010
 */
TOKEN: {
      < INTEGER : (< PLUS_SIGN > | < MINUS_SIGN >)? ["0"-"9"] (["0"-"9"])*                                                >
   |  < DECIMAL : (< PLUS_SIGN > | < MINUS_SIGN >)? ["0"-"9"] (["0"-"9"])* ( "." (["0"-"9"])* )			                >
   |  < HEX	    : (< PLUS_SIGN > | < MINUS_SIGN >)? ["0"-"9", "A"-"F", "a"-"f"] (["0"-"9", "A"-"F", "a"-"f"])* ["h", "H"]	>
   |  < OCT	    : (< PLUS_SIGN > | < MINUS_SIGN >)? ["0"-"7"] (["0"-"7"])* ["o", "O"]									    >
   |  < BIN	    : ( ["0"-"1"] ( ["0"-"1"] )* ["b", "B"] )												                    >
   |  < STRING  : < DOUBLE_QUOTE >( ~[ "\"", "\n", "\r" ] )* < DOUBLE_QUOTE >												>
   |  < TRUE    : "TRUE" | "true" 																		                    >
   |  < FALSE   : "FALSE" | "false"																		                    >
}

/**
 * Identifier
 * @since Setember 25th, 2010
 */
TOKEN : {  
		<IDENTIFIER	: ( < LETTER > |  < UNDERSCORE > ) ( < LETTER > | < DIGIT > |  < UNDERSCORE > )*	>
	|	<#LETTER	: ["A"-"Z", "a"-"z"] >
	|	<#DIGIT		: ["0"-"9"]          > 
}

/**
 * States of the lexical analysis
 */

/**
 * ENDLINE_COMMENT STATE
 */
SKIP: {

	"//" : ENDLINE_COMMENT
}

< ENDLINE_COMMENT > SKIP: {
  
	 "\n" : DEFAULT
   | < ~[] >
}

/**
 * MULTILINE_COMMENT STATE
 */
SKIP: {
  
	"/*" : MULTILINE_COMMENT
}

<MULTILINE_COMMENT > SKIP: {
  
		"*/" : DEFAULT
	|	< ~[] >
}

/**
 * DOCUMENTATION_COMMENT STATE
 */
SKIP: {
  
  "/**" : DOCUMENTATION_COMMENT
}

< DOCUMENTATION_COMMENT > SKIP: {
  
		"*/" : DEFAULT
	|	< ~[] >
}

/**
 * Lexical error catch
 */
SPECIAL_TOKEN: {

	<INVALID_LEXICAL:
		(
			~[
				"a"-"z",
				"A"-"Z",
				"0"-"9",
				"\"",
				"'",
				"`",
				"!",
				"@",
				"#",
				"$",
				"%",
				"(",
				")",
				"-",
				"_",
				"+",
				"*",
				"=",
				"£",
				"¢",
				"¬",
				"§",
				"|",
				"{",
				"}",
				"ª",
				"º",
				"^",
				">",
				" ",
				"\t",
				"\n",
				"\r",
				"\f",
				"<"
			]
		)+
	> {
	  
	  System.err.printf(
	    "Invalid string found from line %d, column %d - %s\n",
	  	input_stream.getBeginLine(),
	  	input_stream.getBeginColumn(),
	  	image
	  );

	  countLexError++;
	}
	| < INVALID_CONST: "\"" (~ ["\n","\r","\""])* ["\n","\r"] > {

		System.err.printf(
	    	"Invalid string found from line %d, column %d - %s\n",
	  		input_stream.getBeginLine(),
	  		input_stream.getBeginColumn(),
	  		image
		);

		countLexError++;
	}
}

/* **************************************************************************************************************
/*                                                Syntax Definition 											*
/* **************************************************************************************************************/

ListNode program() : {

   RelationalOperationsNode r = null;
   ListNode l = null;
}
{
	(
	   r = relationalOperations() < SEMICOLON >
	   
	   {  if ( l == null ) l = new ListNode( r );
	      else l.add( r ); }
	   
	)* < EOF >

	{ return l; }
}

RelationalOperationsNode relationalOperations() : {

   RelationalOperationsNodeChildren opnd = null;
} {

   opnd = query()
//|opnd = structure()
//|opnd = security()

   { return new RelationalOperationsNode( (QueryNode) opnd ); }
}

QueryNode query() : {

   QueryNodeChildren qnc = null;
} {
   
   	qnc = readOnlyOperations() 
	//|  qnc = dataManipulationOperations()
	{ return new QueryNode( qnc ); }
   
}

ReadOnlyOperationsNode readOnlyOperations() : {

	ReadOnlyOperationsNodeChildren roonc = null;
} {
 	( LOOKAHEAD(2) roonc = binaryOperations()
	| roonc = unitaryOperations() 
	)
	{ return new ReadOnlyOperationsNode(roonc); }
}

BinaryOperationsNode binaryOperations() : {
	BinaryOperationsNodeChildren bonc = null;
	BinarySetNode bst = null;
	ReadOnlyOperationsNode roon1 = null;
	ReadOnlyOperationsNode roon2 = null;
	RelationNode rn1 = null;
	RelationNode rn2 = null;
} {
	((< LEFT_PARENTHESIS > roon1 = readOnlyOperations() < RIGHT_PARENTHESIS >) | rn1 = relation())
	( bonc = union()
	| bonc = intersection()
	| bonc = difference()
	| bonc = join()
	| bonc = crossjoin()
    | bonc = division()
	)
	((< LEFT_PARENTHESIS > roon2 = readOnlyOperations() < RIGHT_PARENTHESIS >) | rn2 = relation())
	{
	
	bst = new BinarySetNode();
	if(roon1 != null) bst.addFirstRelation(roon1); else bst.addFirstRelation(rn1);
	if(roon2 != null) bst.addSecondRelation(roon2); else bst.addSecondRelation(rn2);
	return new BinaryOperationsNode(bonc, bst);
	}
}

UnionNode union() : {
	Token t = null;
} {
	t = < OR >
	{ return new UnionNode(t); }
}

IntersectionNode intersection() : {
	Token t = null;
} {
	t = < AND >
	{ return new IntersectionNode(t); }
}

DifferenceNode difference() : {
	Token t = null;
} {
	t = < MINUS_SIGN >
	{ return new DifferenceNode(t); }
}

CrossJoinNode crossjoin() : {
	Token t = null;
} {
	t = < CROSS_TOKEN >
	{ return new CrossJoinNode(t); }
}

JoinNode join() : {
	LogicalSentenceNode lsn = null;
	Token t = null;
} {
	( t = <NATURAL_JOIN_TOKEN>
	| t = < LEFT_BRACKET > [ lsn = logicalSentence() ] < RIGHT_BRACKET >
	)
	{ if(lsn == null) return new JoinNode(t); else return new JoinNode(t, lsn); }
}

DivisionNode division() : {
	Token t = null;
} {
	t = < SOLIDUS >
	{ return new DivisionNode(t); }
}

UnitaryOperationsNode unitaryOperations() : {

	UnitaryOperationsNodeChildren uonc = null;
	ReadOnlyOperationsNode roon = null;
	RelationNode rn = null;
	UnitaryOperationsNode uon = null;
} {
	uon = transitiveClose() { return uon; }
	|(rn = relation() { return new UnitaryOperationsNode( rn );} )
	|(((uonc = project()
	| uonc = select()
	| uonc = rename())
	(< LEFT_PARENTHESIS > roon = readOnlyOperations() < RIGHT_PARENTHESIS > { return new UnitaryOperationsNode(uonc, roon); } ))
	)
}

UnitaryOperationsNode transitiveClose() : {
	UnitaryOperationsNodeChildren uonc = null;
	ReadOnlyOperationsNode roon = null;
	RelationNode rn = null;
	Token t = null;
}{
	t = < TRANSITIVE_CLOSE_LEFT > ( LOOKAHEAD(2) rn = relation() | roon = readOnlyOperations()) < TRANSITIVE_CLOSE_RIGHT >
	{ uonc = new TransitiveCloseNode(t); if(rn==null) return new UnitaryOperationsNode(uonc, roon); else return new UnitaryOperationsNode(uonc, rn); }
}

ProjectNode project() : {
	ListNode ln = null;
	Token token = null;
} {

	< PROJECT_TOKEN > token = < IDENTIFIER >
	{ ln = new ListNode( new AttributeNode( token ) ); }
	(
	  < COMMA > token = < IDENTIFIER >
	  {ln.add( new AttributeNode( token ) );}
	)*
	{ return new ProjectNode(ln); }
}

SelectNode select() : {
	LogicalSentenceNode lsn = null;
} {
   < SELECT_TOKEN > lsn = logicalSentence()
   { return new SelectNode(lsn); }
}

RenameNode rename() : {
	ListNode ln = null;
	Token t1 = null, t2 = null;
} {

   < RENAME_TOKEN > t1 = < IDENTIFIER > t2 = < IDENTIFIER >
   { if(ln==null) ln = new ListNode( new RenameSetNode(t1, t2) );
   	else ln.add( new RenameSetNode(t1, t2) ); }
   ( < COMMA > t1 = < IDENTIFIER > t2 = < IDENTIFIER > 
	{ if(ln==null) ln = new ListNode( new RenameSetNode(t1, t2) );
   	else ln.add( new RenameSetNode(t1, t2) ); }
   )* 
   { return new RenameNode(ln); }
}

RelationNode relation() : {
	Token t = null;
} {
   t = < IDENTIFIER >
   { return new RelationNode(t); }
}

LogicalSentenceNode logicalSentence() : {
	ConditionalSentenceNode csn1 = null;
	ConditionalSentenceNode csn2 = null;
	LogicalOperatorNode lon = null;
	LogicalOperatorNode temp = null;
	Token t = null;
} {
   csn1 = conditionalSentence()
   ( t = logicalOperator() csn2 = conditionalSentence() 
   {
		if(lon == null) { lon = new LogicalOperatorNode(t, csn1, csn2); 
		temp = lon;
		}else{
			temp.add(t, csn2);
			temp = temp.getNextLogicalOperatorNode();
		}
   	})*
   	{
	   	if(lon==null) return new LogicalSentenceNode(csn1);
	   	else return new LogicalSentenceNode(lon);
   	}
}

//TERNARY OPERATOR (IF) NOT IMPLEMENTED YET
ConditionalSentenceNode conditionalSentence() : {
	ComparisonSentenceNode csn = null;
	ComparisonSentenceNode csn1 = null;
	ComparisonSentenceNode csn2 = null;
	ListNode ln = null;
	Token t = null;
} {
   	csn = comparisonSentence() ( t = < IF > csn1 = comparisonSentence() < COLON > csn2 = comparisonSentence()
   	{
   		if(ln == null) ln = new ListNode(new IfNode(t, csn1, csn2)); else ln.add(new IfNode(t, csn1, csn2)); 
   	})*
   	{ if(ln==null) return new ConditionalSentenceNode(csn); else return new ConditionalSentenceNode(csn, ln); }
}

ComparisonSentenceNode comparisonSentence() : {
	InstanceofSentenceNode isn1 = null;
	InstanceofSentenceNode isn2 = null;
	ComparisonOperatorNode con = null;
	ComparisonOperatorNode temp = null;
	Token t = null;
} {
   isn1 = instanceofSentence() ( t = comparisonOperator() isn2 = instanceofSentence() 
   {
   		if(con == null){
	   		con = new ComparisonOperatorNode(t, isn1, isn2);
	   		temp = con;
	   }else{
	   		temp.add(t, isn2);
	   		temp = temp.getNextComparisonOperatorNode();
	   }
	})*
	{
	   	if(con==null) return new ComparisonSentenceNode(isn1);
	   	else return new ComparisonSentenceNode(con);
   	}
}

//NOT IMPLEMENTED YET
InstanceofSentenceNode instanceofSentence() : {
	AdditionSentenceNode asn = null;
	Token type = null;
} {

   asn = additionSentence() [ < INSTANCEOF > type = type() ]
   { if(type != null) return new InstanceofSentenceNode(asn);
   else return new InstanceofSentenceNode(asn, type); }
}  

AdditionSentenceNode additionSentence() : {
	MultiplicationSentenceNode msn1 = null;
	MultiplicationSentenceNode msn2 = null;
	AdditionOperatorNode aon = null;
	AdditionOperatorNode temp = null;
	Token t = null;
} {
   msn1= multiplicationSentence() ( ( t = <PLUS_SIGN> | t = <MINUS_SIGN> ) msn2 = multiplicationSentence() 
   {
   		if(aon == null){
	   		aon = new AdditionOperatorNode(t, msn1, msn2);
	   		temp = aon;
	   }else{
	   		temp.add(t, msn2);
	   		temp = temp.getNextAdditionOperatorNode();
	   }
	})*
	{
	   	if(aon==null) return new AdditionSentenceNode(msn1);
	   	else return new AdditionSentenceNode(aon);
   	}
}

MultiplicationSentenceNode multiplicationSentence() : {
	FactorNode fn1 = null;
	FactorNode fn2 = null;
	MultiplicationOperatorNode mon = null;
	MultiplicationOperatorNode temp = null;
	Token t = null;
} {

   fn1 = factor() ( ( t = < ASTERISK > | t = < POWER > | t = < SOLIDUS > | t = < PERCENT > ) fn2 = factor() 
   {
	   if(mon == null){
	   		mon = new MultiplicationOperatorNode(t, fn1, fn2);
	   		temp = mon;
	   }else{
	   		temp.add(t, fn2);
	   		temp = temp.getNextMultiplicationOperatorNode();
	   }
   })*
   {
	   	if(mon==null) return new MultiplicationSentenceNode(fn1);
	   	else return new MultiplicationSentenceNode(mon);
   	}
}

FactorNode factor() : {
	Token not = null;
	Token t = null;
	ConditionalSentenceNode csn = null;
} {
   [ not = < NOT > ]
   ( t = literal() | t = < IDENTIFIER > | < LEFT_PARENTHESIS > csn = conditionalSentence() < RIGHT_PARENTHESIS > )
   { if(csn == null) return new FactorNode(not, t); else return new FactorNode(not, csn); }
}

Token logicalOperator() : {
	Token t = null;
} {
   ( t = < AND > | t = < OR > | t = < XOR >)
   { return t; }
}

Token comparisonOperator() : {
	Token t = null;
} {
   ( t = < LESS_THAN >
   | t = < LESS_THAN_OR_EQUALS >
   | t = < GREATER_THAN >
   | t = < GREATER_THAN_OR_EQUALS >
   | t = < EQUALS >
   | t = < NOT_EQUALS >)
   { return t; }
}

Token literal() : {
	Token t = null;
} {
	( t = < INTEGER >
	| t = < DECIMAL > 
	| t = < HEX >
	| t = < OCT >
	| t = < BIN >
	| t = < STRING >
	| t = < TRUE >
	| t = < FALSE >)
	{ return t; }
}

Token type() : {
	Token t = null;
} {
    ( t = < VARCHAR_TYPE >
	| t = < CHAR_TYPE >
	| t = < INTEGER_TYPE >
	| t = < DOUBLE_TYPE >
	| t = < FLOAT_TYPE >
	| t = < BLOB_TYPE >
	| t = < GEOMETRIC_TYPE >
	| t = < RELATION_TYPE >
	| t = < BOOLEAN_TYPE >
	| t = < IDENTIFIER >)
	{ return t; }
}